#!/usr/bin/env python3

"""
Makes a request to the Github API and compares
the list of repos from the API to the ones
listed in the README.md

This is used like:

./update 2>/dev/null >> README.md

to append descriptions for any new projects
to this README
"""

import sys
import re
import json
import time
from typing import List, Dict
from pathlib import Path

import requests

import config

def cached_response_has_expired() -> bool:
    """
    Returns T/F which determines whether or not
    to download fresh data from Github API
    """
    if not config.datafile.exists():
        print("Cache file doesn't exist...", file=sys.stderr)
        return True
    if time.time() - config.datafile.stat().st_mtime > 60 * 60 * 6:
        print("Cache file has expired, re-downloading...", file=sys.stderr)
        return True
    else:
        print("Using cached data...", file=sys.stderr)
        return False


# downloads new repository data if needed,
# returns the parsed JSON data
def get_repository_data() -> List[Dict]:
    if not cached_response_has_expired():
        try:
            return json.loads(config.datafile.read_text())
        except json.decoder.JSONDecodeError:
            print("Failed to load JSON from cache file...", file=sys.stderr)
    print(
        f"Downloading repository information for {config.github_username}...",
        file=sys.stderr,
    )
    # loop through the paginated responses to get all repos
    repo_info = []
    page: int = 1
    while True:
        url = f"https://api.github.com/users/{config.github_username}/repos?page={page}"
        print(f"Requesting {url}", file=sys.stderr)
        resp = requests.get(
            url, headers={"Accept": "application/vnd.github.full+json"},
        )
        resp.raise_for_status()
        resp_json = resp.json()
        if resp_json:
            repo_info.extend(resp_json)
        else:
            break
        page += 1
    with config.datafile.open('w') as jf:
        json.dump(repo_info, jf)
    return repo_info


def filter_repos(repo_info: List[Dict]):
    ignore_repos = set(map(str.lower, config.ignore_repos))
    for repo in repo_info:
        # ignore forks if specified to
        if repo["fork"]:
            if not config.include_forks:
                continue
        if repo["name"].lower() in ignore_repos:
            continue
        yield repo


def get_projects_in_readme() -> List[str]:
    readme: Path = config.this_dir / "README.md"
    readme_contents: str = readme.read_text()
    # make sure the line we're looking at is a heading,
    # e.g.:
    # ### project-name
    readme_lines: List[str] = list(
        filter(
            lambda ln: re.match(r"\s*###\s*", ln),
            [ln.strip() for ln in readme_contents.splitlines() if ln.strip()],
        )
    )
    return list(
        map(lambda ln: re.match(r"###\s*([^\s]+)\s*", ln).group(1), readme_lines)
    )


def main():
    # read ./README.md file and filter out
    # headings (which include the names of repos)
    projects_in_readme: List[str] = get_projects_in_readme()

    # request repository information
    repo_info: List[Dict] = get_repository_data()
    print(
        "Found {} repositories for {}...".format(
            len(repo_info), config.github_username
        ),
        file=sys.stderr,
    )

    # filter and sort
    repo_info = list(filter_repos(repo_info))
    repo_info.sort(key=lambda r: r["stargazers_count"], reverse=True)

    # if not in README, print out information that
    # could be turned into a description
    for repo in repo_info:
        if repo["name"] not in projects_in_readme:
            print(
                """### {repo_name}

[GitHub]({github}) | [GitLab]({gitlab}) | {language}

{description}
""".format(
                    repo_name=repo["name"],
                    github=repo["html_url"],
                    gitlab=repo["html_url"].replace("github", "gitlab", 1),
                    language=repo["language"],
                    description=repo["description"],
                )
            )


if __name__ == "__main__":
    main()
